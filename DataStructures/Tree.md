# Tree

If you've seen a family tree, you're already familiar with the concept of a tree. Like a linked list, a tree is made up of nodes. You have a **root node** at the top of a tree. The root node holds references to a number of **child nodes**. In most trees the number of children any **parent node** has is not limited. However, there are particular types of trees that do limit the number of children a node can have. For example a **binary tree** limits the number of children to two. Here's a cool thing about trees, any node can be a root node. The implication of that fact is that trees are a perfect chance to use **recursion**. 

Before moving forward with trees, I would suggest taking the time to either go through the [Recursion](https://github.com/morsedan/UDDTechnicalInterviewPrep/blob/main/Algorithms/Recursion.md) module, or at least familiarize yourself with the concept of recursion. 

Once you are familiar with the idea of recursion, take a look at the video or article on trees.

[Tree Video](https://www.youtube.com/watch?v=qYiBx2pomlQ)
[Tree Article](https://en.wikipedia.org/wiki/Tree_(data_structure))

Test your understanding by implementing a basic binary search tree [here](https://github.com/morsedan/UDTechnicalInterviewPrep/blob/main/DataStructures/BinarySearchTree/BinarySearchTree/main.swift). Or [here](https://github.com/morsedan/UDTechnicalInterviewPrep/blob/main/DataStructures/BinarySearchTree/BinarySearchTree.py) if you use Python.

More practice is available at the following sites:
    - [Leetcode](https://leetcode.com/tag/tree/)
    - [Swift Algorithm Club](https://github.com/raywenderlich/swift-algorithm-club#trees)
